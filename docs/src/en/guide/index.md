# Getting Started

[[toc]]
---

## Hello World

Минимальное приложение выглядит так:

[GitHub](https://github.com/alexpts/go-mux-http/tree/master/mux/tests/app_test.go#L32)
@[code{0-41} go{32-41}](../../../../mux/tests/app_test.go)

## Glossary

#### Middleware

Middleware - это часть приложения, которая отвечает за конкретную единицу логики в обработке
request/response.


#### Layer

Это абстракция, которая является по сути middleware. Layer может иметь как 1 обработчик, так и несколько, чтобы разделить на более мелкие части код по зонам ответственности.


#### App

Приложение является самым высоким уровнем и реализует полную обработку запроса. Приложение реализует интерфейс `Handler` из пакета [`net/http`](https://pkg.go.dev/net/http#Handler). Приложение это набор слоев, которые определяются для каждого http запроса индивидуально в runtime на основе стратегии резолвинга (`IResolver`) слоев и выполняются в друг за другом согласно приоритету слоев.

Задача приложения получить на входе http request (`http.Request`) и записать http response с помощью `http.ResponseWriter`.

Приложение осознано сводит число сущностей к минимуму, чтобы оставаться действительно простым, понятным и надежным. Layer/Слой это основная сущность, с которым придется постоянно работать в `go-http-mux`.

Какие именно слои примут участие в обработке запроса определяется метаинформацией слоя и стратегией резолвинга слоев. Семантически можно выделить следующие типы активации слоев:

- Активация на любом запросе (Layer{} со стандартной конфигурацией срабатывает на все HTTP методы, все пути и тд, не имея ограничений);
- Активация по http методу (слой срабатывает только, если HTTP метод слоя и запроса совпадают);
- Активация по соответствию uri или по регулярному выражению (слой срабатывает, если URI запроса совпадает с `Layer.Path` либо попадает под регулярное выражение слоя);
- Активация по кастомной стратегии (можно реализовать собственные правила активации слоя);

::: details Собственные стратегии
Из коробки идет минимальный набор стратегий (по http методу и поиск по uri). Можно дополнительно реализовать любые кастомные правила, по которым будет принято решение активировать ли слои для обработки запроса или нет. Для этого нужно добавить свою реализацию `resolver.IResolver` и использовать ее в экземпляре `mux.App`
:::

### Handler

Функция обработчик имеет сигнатуру типа [`http.HandlerFunc`](https://pkg.go.dev/net/http#HandlerFunc), то есть полностью совместима со стандартными обработчиками `net/http`

```go
type HandlerFunc func(ResponseWriter, *Request)
```

Чтобы делегировать управление следующему обработчику, нужно вызвать метод `ServerHTTP` на объекте `mux.App`:
```go
    app := mux.NewApp()

    app.Use(layer.Layer{}, func(w http.ResponseWriter, r *http.Request) {
        _, _ = w.Write([]byte("Hello"))
        app.ServerHTTP(w, r)  // invoke next layer/handler
    })
```

Каждый последующий вызов будет итерироваться по обработчикам/слоям и вызывать следующий обработчик.

::: details Проблема стандартного подхода
Стандартный подход go из пакета `net.http` при организации middleware предполагает использование замыканий `func (next http.Handler) http.Handler {}`. Это не позволяет описывать обработчики чистыми функциями и переиспользовать их, как это можно было бы сделать при сигнатуре `func(w ResponseWriter, r *Request, next http.Handler)`.
:::


::: tip Слоенный подход
Каждый слой имеет 1 определенную зону ответственности, это позволяет оставаться вашему коду простым и чистым.
Слой может самостоятельно создать http response и не передавать управление следующему слою. Например, слой, который проверяет аутентификацию, может сам создать http response со статус кодом `401`. С таким подходом, мы можем очень быстро обрабатывать некоторые запросы.

Другой пример, это обработчик, который может кешировать запрос и повторно очень быстро отвечать на запрос из кеша.
:::

### Options

Опции объекта `layer.Layer`

| Опция            | Описание                                                                                                                                                                | По умолчанию        | Пример значения  |
|------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------|------------------|
| **Path**         | описывает uri путь, на который должен активироваться слой, можно использовать регулярки, без указания этого параметра слой активируется на любой uri                    | -                   | `/users/{id}/`   |
| **Name**         | определяем уникальное имя слоя, через это имя можно будет найти слой (по умолчанию все слои получают имена вида `l-0`, `l-1`, `l-2`, и т.д.)                            | -                   | `usersAction`    |
| **Methods**      | принимает slice из http методов, слой активируется только на http запросы с указанными http методами. Если методы не переданы, то слой активируется на любой http метод | `[]`                | `['GET']`        |
| **Priority**     | принимает `int` число с приоритетом, чем ни меньше число, тем раньше выполнится слой. Это позволяет конфигурировать слои декларативно, не в порядке добавления          | `0`                 | `100`            |
| **Restrictions** | принимает массив вида ['id' => \id+], позволяя накладывать дополнительные ограничения на переменны в uri запроса                                                        | `map[string]string` | `['id'=>'\d+']`  |
| **Meta**         | позволяет прикрепить к слою любые произвольные данные                                                                                                                   | `map[string]any`    | `['foo'=>'bar']` |

Пример использования options в коде:

@[code{323-352} go{5-12}](../../../../mux/tests/app_test.go)

### Fast http methods

Для упрощения также доступны методы, которые повторяют основные http методы, например:

```go
app := mux.NewApp()

handler := func(writer http.ResponseWriter, request *http.Request) {
_, _ = writer.Write([]byte(`old mux`))
}

app.
	Get(`/users/{id}/`, handler).
	Post(`/users/{id}/`, handler).
	Put(`/users/{id}/`, handler).
	Patch(`/users/{id}/`, handler).
	Delete(`/users/{id}/`, handler)
```

### Declarative configs

Очень удобно конфигурировать маршруты и порядок декларативно, например посредством yml файлов, простой пример такой конфигурации может выглядеть так:

```yml
# middlewares
ThrowableToResponse:
  controller: xxx

# 404 page
otherwise:
  handler: xxx
  name: otherwise
  priority: 10000

# actions
main:
  path: /
  methods: [ 'GET' ]
  handler: xxx

posts:
  path: /post/
  methods: [ 'GET' ]
  handler: xxx

cat:
  path: /cat/{id}/
  restrictions:
    id: \d+
  methods: [ 'GET' ]
  handler: xxx
```

Модуль не поставляет такую фабрику слоев из коробки, чтобы не ограничивать синтаксис декларативной конфигурации.
Написать такую фабрику это тривиальная задача для разработчика.
[Пример](https://github.com/alexpts/go-edu/blob/master/internal/provider/router.go#L23)

### Inline restriction uri params

Ограничения на параметр в `Path` можно описать дополнительно прямо в `Path` помимо конфигурации опции `Restrictions` у слоя.
Inline формат записи проще для простых регулярок. Для сложных и длинных регулярок лучше использовать явно опцию `Restrictions`, чтобы конфигурация слоя оставалась простой для чтения и интерпретации.
В общем виде такая форма записи выглядит так `{name:restrictRegExp}`.
Следующие конфигурации будут эквивалентны:

```yml
cat:
  path: /cat/{id}/
  restrictions:
    id: \d+

cat2:
  path: /cat/{id:\d+}/
```

::: tip Приоритет
Inline ограничения будут проигнорированы, если этот параметр сконфигурирован через опцию `Restrictions`.

В настоящий момент не все регулярные выражения можно описать inline. Старайтесь применять inline только для простых кейсов.
:::


### Flow

Каждый слой может что-то делать до вызова `ServeHTTP` на следующем обработчике, также может что-то делать после вызова `ServeHTTP`
на этапе ответа. Пример полного выполнения запроса, который проходит сквозь все слои:


<center>

@startuml

scale 1.5
title: 200 response

-> App: http request
    App -> "Auth Layer": ServeHTTP(w, r)
        "Auth Layer" -> Layer2: ServeHTTP(w, r)
            Layer2 -> Action: ServeHTTP(w, r)
            note over Action: некая работа в Action
            Layer2 <- Action:
        "Auth Layer" <- Layer2:
    App <- "Auth Layer":
<- App: http response
@enduml

</center>


Пример flow, когда запрос досрочно может быть обработан одним из слоев, без делегирования обработки следующему обработчику:


<center>

@startuml
scale 1.5
title: 401 response

Client -> App: http request
    activate App
    App -> "Auth Layer": request
    
        activate "Auth Layer"
        "Auth Layer" -> App: 401 response
        deactivate "Auth Layer"
    
    App -> Client: http response
    deactivate App
@enduml

</center>

Каждый слой решает сам, создать http response и прекратить обработку, либо вызвать следующий слой и делегировать ему
тем самым обработку.


## Work with net/http.ServerMux

Так как сигнатуры методов обработчиков полностью совместимы, то можно использовать [http.ServerMux](https://pkg.go.dev/net/http#ServeMux) и `go-mux-http/mux.App` совместно при необходимости или для плавной миграции с `http.ServerMux` 
